# PolyPlanner (new name pending)

PolyPlanner is an execution planner for automated synthetic biology labs. A given lab can be architectured as follows:

1. A higher level business-logic service
2. The PolyPlanner scheduling service on a local network
3. A variety of locally networked equipment with REST APIs

The PolyPlanner acts as a middleman between business specific services and the physical lab environment, queuing procedures that need to occur and executing them when appropriate in the local lab environment.

## Problem

Companies like [Opentrons](https://opentrons.com/) have done a fantastic job at increasing access to automation, but there is still a fundamental problem that prevents companies from moving from partial automation to full automation. That problem is the difficulty in physical movement of material from one location (a freezer) to another location (a robot). Automation of this transfer process is more complex than simply adding robotic arms - each device needs to cooperate with the robotic arm to prevent collisions.

The PolyPlanner bridges this gap by managing local equipment and robotic arms for users. 

## How it works

From a user perspective, the PolyPlanner does the following:

1. The commands of what should be done are generated by the bussiness-logic service (out of scope) and are passed to a standard interface of the PolyPlanner.
2. The PolyPlanner internally schedules the protocol to be executed on machines within its network.
3. When the time is right, the PolyPlanner begins execution of a protocol by sending a REST request to necessary labwares in lab (for example, to open a freezer).
4. The PolyPlanner then occasionally pings the labware to check whether or not request has been successfully executed. This updates the status of the protocol in the PolyPlanner.
5. Then, the PolyPlanner executes the next step of the protocol.
6. GOTO 4 until complete.


## Design

PolyPlanner is designed to be:

1. Transitional to full automation: labs should not be forced to immediately automate their entire pipeline, but rather, there should be a smooth transition period for only certain protocols
in the pipeline.
2. Low capex: labs should be able to reach full automation potential with minimal hardware investment.
3. Upgradable: labs should be able to upgrade hardware over time without changing software at a business-logic level.

### Architecture

coming soon
